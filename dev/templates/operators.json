{"operators":"<div class=\"docs\"><h1>Operators</h1><h2 id=\"operator-precedence\">Operator Precedence</h2><p>Below is the operator precedence table, highest to lowest:</p><div><pre><code> .\r\n []\r\n ! ~ + -\r\n is defined\r\n ** * / %\r\n + -\r\n ... ..\r\n &lt;= &gt;= &lt; &gt;\r\n in\r\n == is != is not isnt\r\n is a\r\n &amp;&amp; and || or\r\n ?:\r\n = := ?= += -= *= /= %=\r\n not\r\n if unless\r\n</code></pre></div><h2 id=\"unary-operators\">Unary Operators</h2><p>The following unary operators are available, <code class=\"highlighter-rouge\">!</code>, <code class=\"highlighter-rouge\">not</code>, <code class=\"highlighter-rouge\">-</code>, <code class=\"highlighter-rouge\">+</code>, and <code class=\"highlighter-rouge\">~</code>.</p><div><pre><code>!0\r\n// =&gt; true\r\n\r\n!!0\r\n// =&gt; false\r\n\r\n!1\r\n// =&gt; false\r\n\r\n!!5px\r\n// =&gt; true\r\n\r\n-5px\r\n// =&gt; -5px\r\n\r\n--5px\r\n// =&gt; 5px\r\n\r\nnot true\r\n// =&gt; false\r\n\r\nnot not true\r\n// =&gt; true\r\n</code></pre></div><p>The logical <code class=\"highlighter-rouge\">not</code> operator has low precedence, therefore the following example could be replaced with</p><div><pre><code>a = 0\r\nb = 1\r\n\r\n!a and !b\r\n// =&gt; false\r\n// parsed as: (!a) and (!b)\r\n</code></pre></div><p>With:</p><div><pre><code>not a or b\r\n// =&gt; false\r\n// parsed as: not (a or b)\r\n</code></pre></div><h2 id=\"binary-operators\">Binary Operators</h2><h3 id=\"subscript-\">Subscript []</h3><p>The subscript operator allows us to grab a value inside an expression via index (zero-based). Negative index values starts with the last element in the expression.</p><div><pre><code> list = 1 2 3\r\n list[0]\r\n // =&gt; 1\r\n\r\n list[-1]\r\n // =&gt; 3\r\n</code></pre></div><p>Parenthesized expressions may act as tuples (e.g. <code class=\"highlighter-rouge\">(15px 5px)</code>, <code class=\"highlighter-rouge\">(1 2 3)</code>).</p><p>Below is an example that uses tuples for error handling (and showcasing the versatility of this construct):</p><div><pre><code> add(a, b)\r\n   if a is a 'unit' and b is a 'unit'\r\n     a + b\r\n   else\r\n     (error 'a and b must be units!')\r\n\r\n body\r\n   padding add(1,'5')\r\n   // =&gt; padding: error \"a and b must be units\";\r\n\r\n   padding add(1,'5')[0]\r\n   // =&gt; padding: error;\r\n\r\n   padding add(1,'5')[0] == error\r\n   // =&gt; padding: true;\r\n\r\n   padding add(1,'5')[1]\r\n   // =&gt; padding: \"a and b must be units\";\r\n</code></pre></div><p>Here’s a more complex example. Now we’re invoking the built-in <code class=\"highlighter-rouge\">error()</code> function with the return error message, whenever the ident (the first value) equals <code class=\"highlighter-rouge\">error</code>.</p><div><pre><code> if (val = add(1,'5'))[0] == error\r\n   error(val[1])\r\n</code></pre></div><h2 id=\"range--\">Range .. …</h2><p>Both the inclusive (<code class=\"highlighter-rouge\">..</code>) and exclusive (<code class=\"highlighter-rouge\">...</code>) range operators are provided, expanding to expressions:</p><div><pre><code> 1..5\r\n // =&gt; 1 2 3 4 5\r\n\r\n 1...5\r\n // =&gt; 1 2 3 4\r\n\r\n 5..1\r\n // =&gt; 5 4 3 2 1\r\n</code></pre></div><h3 id=\"additive---\">Additive: + -</h3><p>Multiplicative and additive binary operators work as expected. Type conversion is applied within unit type classes, or default to the literal value. For example <code class=\"highlighter-rouge\">5s - 2px</code> results in <code class=\"highlighter-rouge\">3s</code>.</p><div><pre><code>15px - 5px\r\n// =&gt; 10px\r\n\r\n5 - 2\r\n// =&gt; 3\r\n\r\n5in - 50mm\r\n// =&gt; 3.031in\r\n\r\n5s - 1000ms\r\n// =&gt; 4s\r\n\r\n20mm + 4in\r\n// =&gt; 121.6mm\r\n\r\n\"foo \" + \"bar\"\r\n// =&gt; \"foo bar\"\r\n\r\n\"num \" + 15\r\n// =&gt; \"num 15\"\r\n</code></pre></div><h3 id=\"multiplicative---\">Multiplicative: / * %</h3><div><pre><code>2000ms + (1s * 2)\r\n// =&gt; 4000ms\r\n\r\n5s / 2\r\n// =&gt; 2.5s\r\n\r\n4 % 2\r\n// =&gt; 0\r\n</code></pre></div><p>When using <code class=\"highlighter-rouge\">/</code> within a property value, you <strong>must</strong> wrap with parens. Otherwise the <code class=\"highlighter-rouge\">/</code> is taken literally (to support CSS <code class=\"highlighter-rouge\">line-height</code>):</p><div><pre><code>font: 14px/1.5;\r\n</code></pre></div><p>But the following is evaluated as <code class=\"highlighter-rouge\">14px</code> ÷ <code class=\"highlighter-rouge\">1.5</code>:</p><div><pre><code>font: (14px/1.5);\r\n</code></pre></div><p>This is <em>only</em> required for the <code class=\"highlighter-rouge\">/</code> operator.</p><h3 id=\"exponent-\">Exponent: **</h3><p>The Exponent operator:</p><div><pre><code>2 ** 8\r\n// =&gt; 256\r\n</code></pre></div><h3 id=\"equality--relational------\">Equality &amp; Relational: == != &gt;= &lt;= &gt; &lt;</h3><p>Equality operators can be used to equate units, colors, strings, and even identifiers. This is a powerful concept, as even arbitrary identifiers (such as as <code class=\"highlighter-rouge\">wahoo</code>) can be utilized as atoms. A function could return <code class=\"highlighter-rouge\">yes</code> or <code class=\"highlighter-rouge\">no</code> instead of <code class=\"highlighter-rouge\">true</code> or <code class=\"highlighter-rouge\">false</code> (although not advised).</p><div><pre><code>5 == 5\r\n// =&gt; true\r\n\r\n10 &gt; 5\r\n// =&gt; true\r\n\r\n#fff == #fff\r\n// =&gt; true\r\n\r\ntrue == false\r\n// =&gt; false\r\n\r\nwahoo == yay\r\n// =&gt; false\r\n\r\nwahoo == wahoo\r\n// =&gt; true\r\n\r\n\"test\" == \"test\"\r\n// =&gt; true\r\n\r\ntrue is true\r\n// =&gt; true\r\n\r\n'hey' is not 'bye'\r\n// =&gt; true\r\n\r\n'hey' isnt 'bye'\r\n// =&gt; true\r\n\r\n(foo bar) == (foo bar)\r\n// =&gt; true\r\n\r\n(1 2 3) == (1 2 3)\r\n// =&gt; true\r\n\r\n(1 2 3) == (1 1 3)\r\n// =&gt; false\r\n</code></pre></div><p>Only exact values match. For example, <code class=\"highlighter-rouge\">0 == false</code> and <code class=\"highlighter-rouge\">null == false</code> are both <code class=\"highlighter-rouge\">false</code>.</p><p>Aliases:</p><div><pre><code>==    is\r\n!=    is not\r\n!=    isnt\r\n</code></pre></div><h2 id=\"truthfulness\">Truthfulness</h2><p>Nearly everything within Stylus resolves to <code class=\"highlighter-rouge\">true</code>, including units with a suffix. Even <code class=\"highlighter-rouge\">0%</code>, <code class=\"highlighter-rouge\">0px</code>, etc. will resolve to <code class=\"highlighter-rouge\">true</code> (because it’s common in Stylus for mixins or functions to accept units as valid).</p><p>However, <code class=\"highlighter-rouge\">0</code> itself is <code class=\"highlighter-rouge\">false</code> in terms of arithmetic.</p><p>Expressions (or “lists”) with a length greater than 1 are considered truthy.</p><p><code class=\"highlighter-rouge\">true</code> examples:</p><div><pre><code>  0%\r\n  0px\r\n  1px\r\n  -1\r\n  -1px\r\n  hey\r\n  'hey'\r\n  (0 0 0)\r\n  ('' '')\r\n</code></pre></div><p><code class=\"highlighter-rouge\">false</code> examples:</p><div><pre><code> 0\r\n null\r\n false\r\n ''\r\n</code></pre></div><h3 id=\"logical-operators---and-or\">Logical Operators: &amp;&amp; || and or</h3><p>Logical operators <code class=\"highlighter-rouge\">&amp;&amp;</code> and <code class=\"highlighter-rouge\">||</code> are aliased <code class=\"highlighter-rouge\">and</code> / <code class=\"highlighter-rouge\">or</code> which apply the same precedence.</p><div><pre><code>5 &amp;&amp; 3\r\n// =&gt; 3\r\n\r\n0 || 5\r\n// =&gt; 5\r\n\r\n0 &amp;&amp; 5\r\n// =&gt; 0\r\n\r\n#fff is a 'rgba' and 15 is a 'unit'\r\n// =&gt; true\r\n</code></pre></div><h3 id=\"existence-operator-in\">Existence Operator: in</h3><p>Checks for the existence of the <em>left-hand</em> operand within the <em>right-hand</em> expression.</p><p>Simple examples:</p><div><pre><code>  nums = 1 2 3\r\n  1 in nums\r\n  // =&gt; true\r\n\r\n  5 in nums\r\n  // =&gt; false\r\n</code></pre></div><p>Some undefined identifiers:</p><div><pre><code>  words = foo bar baz\r\n  bar in words\r\n  // =&gt; true\r\n\r\n  HEY in words\r\n  // =&gt; false\r\n</code></pre></div><p>Works with tuples too:</p><div><pre><code>  vals = (error 'one') (error 'two')\r\n  error in vals\r\n  // =&gt; false\r\n\r\n  (error 'one') in vals\r\n  // =&gt; true\r\n\r\n  (error 'two') in vals\r\n  // =&gt; true\r\n\r\n  (error 'something') in vals\r\n  // =&gt; false\r\n</code></pre></div><p>Example usage in mixin:</p><div><pre><code>  pad(types = padding, n = 5px)\r\n    if padding in types\r\n      padding n\r\n    if margin in types\r\n      margin n\r\n\r\n  body\r\n    pad()\r\n\r\n  body\r\n    pad(margin)\r\n\r\n  body\r\n    pad(padding margin, 10px)\r\n</code></pre></div><p>Yielding:</p><div><pre><code>  body {\r\n    padding: 5px;\r\n  }\r\n  body {\r\n    margin: 5px;\r\n  }\r\n  body {\r\n    padding: 10px;\r\n    margin: 10px;\r\n  }\r\n</code></pre></div><h3 id=\"conditional-assignment--\">Conditional Assignment: ?= :=</h3><p>The conditional assignment operator <code class=\"highlighter-rouge\">?=</code> (aliased as <code class=\"highlighter-rouge\">:=</code>) lets us define variables without clobbering old values (if present). This operator expands to an <code class=\"highlighter-rouge\">is defined</code> binary operation within a ternary.</p><p>For example, the following are equivalent:</p><div><pre><code>color := white\r\ncolor ?= white\r\ncolor = color is defined ? color : white\r\n</code></pre></div><p>When using plain <code class=\"highlighter-rouge\">=</code>, we simply reassign:</p><div><pre><code>color = white\r\ncolor = black\r\n\r\ncolor\r\n// =&gt; black\r\n</code></pre></div><p>But when using <code class=\"highlighter-rouge\">?=</code>, our second attempt fails (since the variable is already defined):</p><div><pre><code>color = white\r\ncolor ?= black\r\n\r\ncolor\r\n// =&gt; white\r\n</code></pre></div><h3 id=\"instance-check-is-a\">Instance Check: is a</h3><p>Stylus provides a binary operator named <code class=\"highlighter-rouge\">is a</code> used to type check.</p><div><pre><code>15 is a 'unit'\r\n// =&gt; true\r\n\r\n#fff is a 'rgba'\r\n// =&gt; true\r\n\r\n15 is a 'rgba'\r\n// =&gt; false\r\n</code></pre></div><p>Alternatively, we could use the <code class=\"highlighter-rouge\">type()</code> BIF:</p><div><pre><code>type(#fff) == 'rgba'\r\n// =&gt; true\r\n</code></pre></div><p><strong>Note:</strong> <code class=\"highlighter-rouge\">color</code> is the only special-case, evaluating to <code class=\"highlighter-rouge\">true</code> when the left-hand operand is an <code class=\"highlighter-rouge\">RGBA</code> or <code class=\"highlighter-rouge\">HSLA</code> node.</p><h3 id=\"variable-definition-is-defined\">Variable Definition: is defined</h3><p>This pseudo binary operator does not accept a right-hand operator, and does <em>not</em> evaluate the left. This allows us to check if a variable has a value assigned to it.</p><div><pre><code>foo is defined\r\n// =&gt; false\r\n\r\nfoo = 15px\r\nfoo is defined\r\n// =&gt; true\r\n\r\n#fff is defined\r\n// =&gt; 'invalid \"is defined\" check on non-variable #fff'\r\n</code></pre></div><p>Alternatively, one can use the <code class=\"highlighter-rouge\">lookup(name)</code> built-in function to do this—or to perform dynamic lookups:</p><div><pre><code>name = 'blue'\r\nlookup('light-' + name)\r\n// =&gt; null\r\n\r\nlight-blue = #80e2e9\r\nlookup('light-' + name)\r\n// =&gt; #80e2e9\r\n</code></pre></div><p>This operator is essential, as an undefined identifier is still a truthy value. For example:</p><div><pre><code>body\r\n  if ohnoes\r\n    padding 5px\r\n</code></pre></div><p><em>Will</em> yield the following CSS when undefined:</p><div><pre><code>body {\r\n  padding: 5px;\r\n}\r\n</code></pre></div><p>However this will be safe:</p><div><pre><code>body\r\n  if ohnoes is defined\r\n    padding 5px\r\n</code></pre></div><h2 id=\"ternary\">Ternary</h2><p>The ternary operator works as we would expect in most languages. It’s the only operator with three operands (the <em>condition</em> expression, the <em>truth</em> expression, and the <em>false</em> expression).</p><div><pre><code>num = 15\r\nnum ? unit(num, 'px') : 20px\r\n// =&gt; 15px\r\n</code></pre></div><h2 id=\"casting\">Casting</h2><p>As an terse alternative to the <code class=\"highlighter-rouge\">unit()</code> built-in function, the syntax <code class=\"highlighter-rouge\">(expr) unit</code> may be used to force the suffix.</p><div><pre><code>body\r\n  n = 5\r\n  foo: (n)em\r\n  foo: (n)%\r\n  foo: (n + 5)%\r\n  foo: (n * 5)px\r\n  foo: unit(n + 5, '%')\r\n  foo: unit(5 + 180 / 2, deg)\r\n</code></pre></div><h2 id=\"color-operations\">Color Operations</h2><p>Operations on colors provide a terse, expressive way to alter components. For example, we can operate on each RGB:</p><div><pre><code>#0e0 + #0e0\r\n// =&gt; #0f0\r\n</code></pre></div><p>Another example is adjust the lightness value by adding or subtracting a percentage. To lighten a color, add; to darken, subtract.</p><div><pre><code>#888 + 50%\r\n// =&gt; #c3c3c3\r\n\r\n#888 - 50%\r\n// =&gt; #444\r\n</code></pre></div><p>Adjust the hue is also possible by adding or subtracting with degrees. For example, adding <code class=\"highlighter-rouge\">50deg</code> to this red value results in a yellow:</p><div><pre><code> #f00 + 50deg\r\n // =&gt; #ffd500\r\n</code></pre></div><p>Values clamp appropriately. For example, we can “spin” the hue 180 degrees, and if the current value is <code class=\"highlighter-rouge\">320deg</code>, it will resolve to <code class=\"highlighter-rouge\">140deg</code>.</p><p>We may also tweak several values at once (including the alpha) by using <code class=\"highlighter-rouge\">rgb()</code>, <code class=\"highlighter-rouge\">rgba()</code>, <code class=\"highlighter-rouge\">hsl()</code>, or <code class=\"highlighter-rouge\">hsla()</code>:</p><div><pre><code>  #f00 - rgba(100,0,0,0.5)\r\n  // =&gt; rgba(155,0,0,0.5)\r\n</code></pre></div><h2 id=\"sprintf\">Sprintf</h2><p>The string sprintf-like operator <code class=\"highlighter-rouge\">%</code> can be used to generate a literal value, internally passing arguments through the <code class=\"highlighter-rouge\">s()</code> built-in:</p><div><pre><code>   'X::Microsoft::Crap(%s)' % #fc0\r\n   // =&gt; X::Microsoft::Crap(#fc0)\r\n</code></pre></div><p>Multiple values should be parenthesized:</p><div><pre><code>  '-webkit-gradient(%s, %s, %s)' % (linear (0 0) (0 100%))\r\n  // =&gt; -webkit-gradient(linear, 0 0, 0 100%)\r\n</code></pre></div></div>\r\n"}