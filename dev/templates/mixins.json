{"mixins":"<div class=\"docs\"><h1>Mixins</h1><p>Both mixins and functions are defined in the same manner, but they are applied in different ways.</p><p>For example, we have a <code class=\"highlighter-rouge\">border-radius(n)</code> function defined below, which is invoked as a <em>mixin</em> (i.e., invoked as a statement, rather than part of an expression).</p><p>When <code class=\"highlighter-rouge\">border-radius()</code> is invoked within a selector, the properties are expanded and copied into the selector.</p><div><pre><code>border-radius(n)\r\n  -webkit-border-radius n\r\n  -moz-border-radius n\r\n  border-radius n\r\n\r\nform input[type=button]\r\n  border-radius(5px)\r\n</code></pre></div><p>Compiles to:</p><div><pre><code>form input[type=button] {\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n}\r\n</code></pre></div><p>When using mixins you can omit the parentheses altogether, providing fantastic transparent vendor property support!</p><div><pre><code>border-radius(n)\r\n  -webkit-border-radius n\r\n  -moz-border-radius n\r\n  border-radius n\r\n\r\nform input[type=button]\r\n  border-radius 5px\r\n</code></pre></div><p>Note that the <code class=\"highlighter-rouge\">border-radius</code> within our mixin is treated as a property, and not a recursive function invocation.</p><p>To take this further, we can utilize the automatic <code class=\"highlighter-rouge\">arguments</code> local variable, containing the expression passed, allowing multiple values to be passed:</p><div><pre><code>border-radius()\r\n  -webkit-border-radius arguments\r\n  -moz-border-radius arguments\r\n  border-radius arguments\r\n</code></pre></div><p>Now we can pass values like <code class=\"highlighter-rouge\">border-radius 1px 2px / 3px 4px</code>!</p><p>Another great use of this is the addition of transparent support for vendor-specifics—such as <code class=\"highlighter-rouge\">opacity</code> support for IE:</p><div><pre><code>    support-for-ie ?= true\r\n\r\n    opacity(n)\r\n      opacity n\r\n      if support-for-ie\r\n        filter unquote('progid:DXImageTransform.Microsoft.Alpha(Opacity=' + round(n * 100) + ')')\r\n\r\n    #logo\r\n      &amp;:hover\r\n        opacity 0.5\r\n</code></pre></div><p>Rendering:</p><div><pre><code>    #logo:hover {\r\n      opacity: 0.5;\r\n      filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50);\r\n    }\r\n</code></pre></div><h2 id=\"parent-references\">Parent References</h2><p>Mixins may utilize the parent reference character <code class=\"highlighter-rouge\">&amp;</code>, acting on the parent instead of further nesting.</p><p>For example, let’s say we want to create a <code class=\"highlighter-rouge\">stripe(even, odd)</code> mixin for striping table rows. We provide both <code class=\"highlighter-rouge\">even</code> and <code class=\"highlighter-rouge\">odd</code> with default color values, and assign the <code class=\"highlighter-rouge\">background-color</code> property on the row. Nested within the <code class=\"highlighter-rouge\">tr</code> we use <code class=\"highlighter-rouge\">&amp;</code> to reference the <code class=\"highlighter-rouge\">tr</code>, providing the <code class=\"highlighter-rouge\">even</code> color.</p><div><pre><code> stripe(even = #fff, odd = #eee)\r\n   tr\r\n     background-color odd\r\n     &amp;.even\r\n     &amp;:nth-child(even)\r\n       background-color even\r\n</code></pre></div><p>We may then utilize the mixin as shown below:</p><div><pre><code> table\r\n   stripe()\r\n   td\r\n     padding 4px 10px\r\n\r\n table#users\r\n   stripe(#303030, #494848)\r\n   td\r\n     color white\r\n</code></pre></div><p>Alternatively, <code class=\"highlighter-rouge\">stripe()</code> could be defined without parent references:</p><div><pre><code>stripe(even = #fff, odd = #eee)\r\n  tr\r\n    background-color odd\r\n  tr.even\r\n  tr:nth-child(even)\r\n    background-color even\r\n</code></pre></div><p>If we wished, we could invoke <code class=\"highlighter-rouge\">stripe()</code> as if it were a property:</p><div><pre><code>stripe #fff #000\r\n</code></pre></div><h2 id=\"block-mixins\">Block mixins</h2><p>You can pass blocks to mixins by calling mixin with <code class=\"highlighter-rouge\">+</code> prefix:</p><div><pre><code>+foo()\r\n  width: 10px\r\n</code></pre></div><p>The passed block would be available inside the mixin as <code class=\"highlighter-rouge\">block</code> variable, that then could be used with interpolation:</p><div><pre><code>foo()\r\n  .bar\r\n    {block}\r\n\r\n+foo()\r\n  width: 10px\r\n\r\n=&gt; .bar {\r\n     width: 10px;\r\n   }\r\n</code></pre></div><p>This feature is in its rough state ATM, but would be enhanced in the future.</p><h2 id=\"mixing-mixins-in-mixins\">Mixing Mixins in Mixins</h2><p>Mixins can (of course!) utilize other mixins, building upon their own selectors and properties.</p><p>For example, below we create <code class=\"highlighter-rouge\">comma-list()</code> to inline (via <code class=\"highlighter-rouge\">inline-list()</code>) and comma-separate an unordered list.</p><div><pre><code> inline-list()\r\n   li\r\n     display inline\r\n\r\n comma-list()\r\n   inline-list()\r\n   li\r\n     &amp;:after\r\n       content ', '\r\n     &amp;:last-child:after\r\n       content ''\r\n\r\n ul\r\n   comma-list()\r\n</code></pre></div><p>Rendering:</p><div><pre><code>ul li:after {\r\n  content: \", \";\r\n}\r\nul li:last-child:after {\r\n  content: \"\";\r\n}\r\nul li {\r\n  display: inline;\r\n}\r\n</code></pre></div></div>\r\n"}