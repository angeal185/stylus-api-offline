{"functions":"<div class=\"docs\"><h1>Functions</h1><p>Stylus features powerful in-language function definitions. Function definitions appear identical to mixins; however, functions may return a value.</p><h2 id=\"return-values\">Return Values</h2><p>Let’s try a trivial example: creating a function that adds two numbers.</p><div><pre><code>add(a, b)\r\n  a + b\r\n</code></pre></div><p>We can then use this function in conditions, in property values, etc.</p><div><pre><code> body\r\n   padding add(10px, 5)\r\n</code></pre></div><p>Rendering:</p><div><pre><code> body {\r\n   padding: 15px;\r\n }\r\n</code></pre></div><h2 id=\"argument-defaults\">Argument Defaults</h2><p>Optional arguments may default to a given expression. With Stylus we may even default arguments to earlier arguments!</p><p>For example:</p><div><pre><code> add(a, b = a)\r\n   a + b\r\n\r\n add(10, 5)\r\n // =&gt; 15\r\n\r\n add(10)\r\n // =&gt; 20\r\n</code></pre></div><p><strong>Note:</strong> Since argument defaults are assignments, we can also use function calls for defaults:</p><div><pre><code> add(a, b = unit(a, px))\r\n   a + b\r\n</code></pre></div><h2 id=\"named-parameters\">Named Parameters</h2><p>Functions accept named parameters. This frees you from remembering the order of parameters, or simply improves the readability of your code.</p><p>For example:</p><div><pre><code>subtract(a, b)\r\n  a - b\r\n\r\nsubtract(b: 10, a: 25)\r\n</code></pre></div><h2 id=\"function-bodies\">Function Bodies</h2><p>We can take our simple <code class=\"highlighter-rouge\">add()</code> function further. Let’s casting all units passed as <code class=\"highlighter-rouge\">px</code> via the <code class=\"highlighter-rouge\">unit()</code> built-in. It reassigns each argument, and provides a unit-type string (or identifier), which ignores unit conversion.</p><div><pre><code> add(a, b = a)\r\n   a = unit(a, px)\r\n   b = unit(b, px)\r\n   a + b\r\n\r\n add(15%, 10deg)\r\n // =&gt; 25\r\n</code></pre></div><h2 id=\"multiple-return-values\">Multiple Return Values</h2><p>Stylus functions can return several values—just as you can assign several values to a variable.</p><p>For example, the following is a valid assignment:</p><div><pre><code>   sizes = 15px 10px\r\n\r\n   sizes[0]\r\n   // =&gt; 15px\r\n</code></pre></div><p>Similarly, we may return several values:</p><div><pre><code>   sizes()\r\n     15px 10px\r\n\r\n   sizes()[0]\r\n   // =&gt; 15px\r\n</code></pre></div><p>One slight exception is when return values are identifiers. For example, the following looks like a property assignment to Stylus (since no operators are present):</p><div><pre><code> swap(a, b)\r\n   b a\r\n</code></pre></div><p>To disambiguate, we can either wrap with parentheses, or use the <code class=\"highlighter-rouge\">return</code> keyword:</p><div><pre><code>  swap(a, b)\r\n    (b a)\r\n\r\n  swap(a, b)\r\n    return b a\r\n</code></pre></div><h2 id=\"conditionals\">Conditionals</h2><p>Let’s say we want to create a function named <code class=\"highlighter-rouge\">stringish()</code> to determine whether the argument can be transformed to a string. We check if <code class=\"highlighter-rouge\">val</code> is a string, or an ident (which is string-like). Because undefined identifiers yield themselves as the value, we may compare them to themselves as shown below (where <code class=\"highlighter-rouge\">yes</code> and <code class=\"highlighter-rouge\">no</code> are used in place of <code class=\"highlighter-rouge\">true</code> and <code class=\"highlighter-rouge\">false</code>):</p><div><pre><code> stringish(val)\r\n   if val is a 'string' or val is a 'ident'\r\n     yes\r\n   else\r\n     no\r\n</code></pre></div><p>Usage:</p><div><pre><code> stringish('yay') == yes\r\n // =&gt; true\r\n\r\n stringish(yay) == yes\r\n // =&gt; true\r\n\r\n stringish(0) == no\r\n // =&gt; true\r\n</code></pre></div><p><strong>note</strong>: <code class=\"highlighter-rouge\">yes</code> and <code class=\"highlighter-rouge\">no</code> are not boolean literals. They are simply undefined identifiers in this case.</p><p>Another example:</p><div><pre><code>compare(a, b)\r\n  if a &gt; b\r\n    higher\r\n  else if a &lt; b\r\n    lower\r\n  else\r\n    equal\r\n</code></pre></div><p>Usage:</p><div><pre><code>compare(5, 2)\r\n// =&gt; higher\r\n\r\ncompare(1, 5)\r\n// =&gt; lower\r\n\r\ncompare(10, 10)\r\n// =&gt; equal\r\n</code></pre></div><h2 id=\"aliasing\">Aliasing</h2><p>To alias a function, simply assign a function’s name to a new identifier. For example, our <code class=\"highlighter-rouge\">add()</code> function could be aliased as <code class=\"highlighter-rouge\">plus()</code>, like so:</p><div><pre><code>  plus = add\r\n\r\n  plus(1, 2)\r\n  // =&gt; 3\r\n</code></pre></div><h2 id=\"variable-functions\">Variable Functions</h2><p>In the same way that we can “alias” a function, we can pass a function as well. Here, our <code class=\"highlighter-rouge\">invoke()</code> function accepts a function, so we can pass it <code class=\"highlighter-rouge\">add()</code> or <code class=\"highlighter-rouge\">sub()</code>.</p><div><pre><code>add(a, b)\r\n  a + b\r\n\r\nsub(a, b)\r\n  a - b\r\n\r\ninvoke(a, b, fn)\r\n  fn(a, b)\r\n\r\nbody\r\n  padding invoke(5, 10, add)\r\n  padding invoke(5, 10, sub)\r\n</code></pre></div><p>Yielding:</p><div><pre><code>body {\r\n  padding: 15;\r\n  padding: -5;\r\n}\r\n</code></pre></div><h2 id=\"anonymous-functions\">Anonymous functions</h2><p>You can use anonymous functions where needed using <code class=\"highlighter-rouge\">@(){}</code> syntax. Here is how you could use it to create a custom <code class=\"highlighter-rouge\">sort()</code> function:</p><div><pre><code>sort(list, fn = null)\r\n  // default sort function\r\n  if fn == null\r\n    fn = @(a, b) {\r\n      a &gt; b\r\n    }\r\n\r\n  // bubble sort\r\n  for $i in 1..length(list) - 1\r\n    for $j in 0..$i - 1\r\n      if fn(list[$j], list[$i])\r\n        $temp = list[$i]\r\n        list[$i] = list[$j]\r\n        list[$j] = $temp\r\n  return list\r\n\r\n  sort('e' 'c' 'f' 'a' 'b' 'd')\r\n  // =&gt; 'a' 'b' 'c' 'd' 'e' 'f'\r\n\r\n  sort(5 3 6 1 2 4, @(a, b){\r\n    a &lt; b\r\n  })\r\n  // =&gt; 6 5 4 3 2 1\r\n</code></pre></div><h2 id=\"arguments\">arguments</h2><p>The <code class=\"highlighter-rouge\">arguments</code> local is available to all function bodies, and contains all the arguments passed.</p><p>For example:</p><div><pre><code> sum()\r\n   n = 0\r\n   for num in arguments\r\n     n = n + num\r\n\r\n sum(1,2,3,4,5)\r\n // =&gt; 15\r\n</code></pre></div><h2 id=\"hash-example\">Hash Example</h2><p>Below we define the <code class=\"highlighter-rouge\">get(hash, key)</code> function, which returns the value of <code class=\"highlighter-rouge\">key</code> (or <code class=\"highlighter-rouge\">null</code>). We iterate each <code class=\"highlighter-rouge\">pair</code> in <code class=\"highlighter-rouge\">hash</code>, returning the pair’s second node when the first (the <code class=\"highlighter-rouge\">key</code>) matches.</p><div><pre><code>  get(hash, key)\r\n    return pair[1] if pair[0] == key for pair in hash\r\n</code></pre></div><p>As demonstrated below, in-language functions—paired with robust Stylus expressions—can provide great flexibility:</p><div><pre><code>  hash = (one 1) (two 2) (three 3)\r\n\r\n  get(hash, two)\r\n  // =&gt; 2\r\n\r\n  get(hash, three)\r\n  // =&gt; 3\r\n\r\n  get(hash, something)\r\n  // =&gt; null\r\n</code></pre></div></div>\r\n"}