{"selectors":"<div class=\"docs\"><h1>Selectors</h1><h2 id=\"indentation\">Indentation</h2><p>Stylus is “pythonic” (i.e. indentation-based). Whitespace is significant, so we substitute <code class=\"highlighter-rouge\">{</code> and <code class=\"highlighter-rouge\">}</code> with an <em>indent</em>, and an <em>outdent</em> as shown below:</p><div><pre><code>body\r\n  color white\r\n</code></pre></div><p>Which compiles to:</p><div><pre><code>body {\r\n  color: #fff;\r\n}\r\n</code></pre></div><p>If preferred, you can use colons to separate properties and values:</p><div><pre><code>body\r\n  color: white\r\n</code></pre></div><h2 id=\"rule-sets\">Rule Sets</h2><p>Stylus, just like CSS, allows you to define properties for several selectors at once through comma separation.</p><div><pre><code>textarea, input\r\n  border 1px solid #eee\r\n</code></pre></div><p>The same can be done with a newline:</p><div><pre><code>textarea\r\ninput\r\n  border 1px solid #eee\r\n</code></pre></div><p>Both compile to:</p><div><pre><code>textarea,\r\ninput {\r\n  border: 1px solid #eee;\r\n}\r\n</code></pre></div><p><strong>The only exception to this rule</strong> are selectors that look like properties. For example, the following <code class=\"highlighter-rouge\">foo bar baz</code> might be a property <strong>or</strong> a selector:</p><div><pre><code>foo bar baz\r\n&gt; input\r\n  border 1px solid\r\n</code></pre></div><p>So for this reason (or simply if preferred), we may trail with a comma:</p><div><pre><code>foo bar baz,\r\nform input,\r\n&gt; a\r\n  border 1px solid\r\n</code></pre></div><h2 id=\"parent-reference\">Parent Reference</h2><p>The <code class=\"highlighter-rouge\">&amp;</code> character references the parent selector(s). In the example below our two selectors (<code class=\"highlighter-rouge\">textarea</code> and <code class=\"highlighter-rouge\">input</code>) both alter the <code class=\"highlighter-rouge\">color</code> on the <code class=\"highlighter-rouge\">:hover</code> pseudo selector.</p><div><pre><code>textarea\r\ninput\r\n  color #A7A7A7\r\n  &amp;:hover\r\n    color #000\r\n</code></pre></div><p>Compiles to:</p><div><pre><code>textarea,\r\ninput {\r\n  color: #a7a7a7;\r\n}\r\ntextarea:hover,\r\ninput:hover {\r\n  color: #000;\r\n}\r\n</code></pre></div><p>Below is an example providing a simple <code class=\"highlighter-rouge\">2px</code> border for Internet Explorer utilizing the parent reference within a mixin:</p><div><pre><code>  box-shadow()\r\n    -webkit-box-shadow arguments\r\n    -moz-box-shadow arguments\r\n    box-shadow arguments\r\n    html.ie8 &amp;,\r\n    html.ie7 &amp;,\r\n    html.ie6 &amp;\r\n      border 2px solid arguments[length(arguments) - 1]\r\n\r\n  body\r\n    #login\r\n      box-shadow 1px 1px 3px #eee\r\n</code></pre></div><p>Yielding:</p><div><pre><code>  body #login {\r\n    -webkit-box-shadow: 1px 1px 3px #eee;\r\n    -moz-box-shadow: 1px 1px 3px #eee;\r\n    box-shadow: 1px 1px 3px #eee;\r\n  }\r\n  html.ie8 body #login,\r\n  html.ie7 body #login,\r\n  html.ie6 body #login {\r\n    border: 2px solid #eee;\r\n  }\r\n</code></pre></div><p>If you’d need to use the ampersand symbol in a selector without it behaving like a parent reference, you can just escape it:</p><div><pre><code>.foo[title*='\\&amp;']\r\n// =&gt; .foo[title*='&amp;']\r\n</code></pre></div><h2 id=\"partial-reference\">Partial Reference</h2><p><code class=\"highlighter-rouge\">^[N]</code> anywhere in a selector, where <code class=\"highlighter-rouge\">N</code> can be a number, represents a partial reference.</p><p>Partial reference works similar to the parent reference, but while parent reference contains the whole selector, partial selectors contain only the first merged <code class=\"highlighter-rouge\">N</code> levels of the nested selectors, so you could access those nesting levels individually.</p><p>The <code class=\"highlighter-rouge\">^[0]</code> would give you the selector from the first level, the <code class=\"highlighter-rouge\">^[1]</code> would give you the rendered selector from the second level and so on:</p><div><pre><code>.foo\r\n  &amp;__bar\r\n    width: 10px\r\n\r\n    ^[0]:hover &amp;\r\n      width: 20px\r\n</code></pre></div><p>would be rendered as</p><div><pre><code>.foo__bar {\r\n  width: 10px;\r\n}\r\n.foo:hover .foo__bar {\r\n  width: 20px;\r\n}\r\n</code></pre></div><p>Negative values are counting from the end, so ^[-1] would give you the last selector from the chain before <code class=\"highlighter-rouge\">&amp;</code>:</p><div><pre><code>.foo\r\n  &amp;__bar\r\n    &amp;_baz\r\n      width: 10px\r\n\r\n      ^[-1]:hover &amp;\r\n        width: 20px\r\n</code></pre></div><p>would be rendered as</p><div><pre><code>.foo__bar_baz {\r\n  width: 10px;\r\n}\r\n.foo__bar:hover .foo__bar_baz {\r\n  width: 20px;\r\n}\r\n</code></pre></div><p>Negative values are especially helpful for usage inside mixins when you don’t know at what nesting level you’re calling it.</p><hr><p>Note that partial reference contain the whole rendered chain of selectors until the given nesting level, not the “part” of the selector.</p><h3 id=\"ranges-in-partial-references\">Ranges in partial references</h3><p><code class=\"highlighter-rouge\">^[N..M]</code> anywhere in a selector, where both <code class=\"highlighter-rouge\">N</code> and <code class=\"highlighter-rouge\">M</code> can be numbers, represents a partial reference.</p><p>If you’d have a case when you’d need to get the raw part of the selector, or to get the range of parts programmatically, you could use ranges inside partial reference.</p><p>If the range would start from the positive value, the result won’t contain the selectors of the previous levels and you’d get the result as if the selectors of those levels were inserted at the root of the stylesheet with the combinators omitted:</p><div><pre><code>.foo\r\n  &amp; .bar\r\n    width: 10px\r\n\r\n    ^[0]:hover ^[1..-1]\r\n      width: 20px\r\n</code></pre></div><p>would be rendered as</p><div><pre><code>.foo .bar {\r\n  width: 10px;\r\n}\r\n.foo:hover .bar {\r\n  width: 20px;\r\n}\r\n</code></pre></div><p>One number in the range would be the start index, the second — the end index. Note that the order of those numbers won’t matter as the selectors would always render from the first levels to the last, so <code class=\"highlighter-rouge\">^[1..-1]</code> would be equal to the <code class=\"highlighter-rouge\">^[-1..1]</code>.</p><p>When both numbers are equal, the result would be just one raw level of a selector, so you could replace <code class=\"highlighter-rouge\">^[1..-1]</code> in a previous example to <code class=\"highlighter-rouge\">^[-1..-1]</code>, and it would be equal to the same last one raw selector, but would be more reliable if used inside mixins.</p><h2 id=\"initial-reference\">Initial Reference</h2><p>The <code class=\"highlighter-rouge\">~/</code> characters at the start of a selector can be used to point at the selector at the first nesting and could be considered as a shortcut to <code class=\"highlighter-rouge\">^[0]</code>. The only drawback is that you can use initial reference only at the start of a selector:</p><div><pre><code>.block\r\n  &amp;__element\r\n    ~/:hover &amp;\r\n      color: red\r\n</code></pre></div><p>Would be rendered as</p><div><pre><code>.block:hover .block__element {\r\n  color: #f00;\r\n}\r\n</code></pre></div><h2 id=\"relative-reference\">Relative Reference</h2><p>The <code class=\"highlighter-rouge\">../</code> characters at the start of a selector mark a relative reference, which points to the previous to the <code class=\"highlighter-rouge\">&amp;</code> compiled selector. You can nest relative reference: <code class=\"highlighter-rouge\">../../</code> to get deeper levels, but note that it can be used only at the start of the selector.</p><div><pre><code>.foo\r\n  .bar\r\n    width: 10px\r\n\r\n    &amp;,\r\n    ../ .baz\r\n      height: 10px\r\n</code></pre></div><p>would be rendered as</p><div><pre><code>.foo .bar {\r\n  width: 10px;\r\n}\r\n.foo .bar,\r\n.foo .baz {\r\n  height: 10px;\r\n}\r\n</code></pre></div><p>Relative references can be considered as shortcuts to the partial references with ranges like <code class=\"highlighter-rouge\">^[0..-(N + 1)]</code> where the <code class=\"highlighter-rouge\">N</code> is the number of relative references used.</p><h2 id=\"root-reference\">Root Reference</h2><p>The <code class=\"highlighter-rouge\">/</code> character at the start of a selector is a root reference. It references the root context and this means the selector won’t prepend the parent’s selector to it (unless you would use it with <code class=\"highlighter-rouge\">&amp;</code>). It is helpful when you need to write some styles both to some nested selector and to another one, not in the current scope.</p><div><pre><code>textarea\r\ninput\r\n  color #A7A7A7\r\n  &amp;:hover,\r\n  /.is-hovered\r\n    color #000\r\n</code></pre></div><p>Compiles to:</p><div><pre><code>textarea,\r\ninput {\r\n  color: #a7a7a7;\r\n}\r\ntextarea:hover,\r\ninput:hover,\r\n.is-hovered {\r\n  color: #000;\r\n}\r\n</code></pre></div><h2 id=\"selector-bif\">selector() bif</h2><p>You can use the built-in <code class=\"highlighter-rouge\">selector()</code> to get the current compiled selector. Could be used inside mixins for checks or other clever things.</p><div><pre><code>.foo\r\n  selector()\r\n// =&gt; '.foo'\r\n\r\n.foo\r\n  &amp;:hover\r\n    selector()\r\n// '.foo:hover'\r\n</code></pre></div><p>This bif could also accept an optional string argument, in this case it would return the compiled selector. Note that it wouldn’t prepend the selector of the current scope in case it don’t have any <code class=\"highlighter-rouge\">&amp;</code> symbols.</p><div><pre><code>.foo\r\n  selector('.bar')\r\n// =&gt; '.bar'\r\n\r\n.foo\r\n  selector('&amp;:hover')\r\n// '.foo:hover'\r\n</code></pre></div><h3 id=\"multiple-values-for-selector-bif\">Multiple values for <code class=\"highlighter-rouge\">selector()</code> bif</h3><p><code class=\"highlighter-rouge\">selector()</code> bif can accept multiple values or a comma-separated list in order to create a nested selector structure easier.</p><div><pre><code>{selector('.a', '.b', '.c, .d')}\r\n  color: red\r\n</code></pre></div><p>would be equal to the</p><div><pre><code>.a\r\n  .b\r\n    .c,\r\n    .d\r\n      color: red\r\n</code></pre></div><p>and would be rendered as</p><div><pre><code>.a .b .c,\r\n.a .b .d {\r\n  color: #f00;\r\n}\r\n</code></pre></div><h2 id=\"selectors-bif\">selectors() bif</h2><p>This bif returns a comma-separated list of nested selectors for the current level:</p><div><pre><code>.a\r\n  .b\r\n    &amp;__c\r\n      content: selectors()\r\n</code></pre></div><p>would be rendered as</p><div><pre><code>.a .b__c {\r\n  content: '.a', '&amp; .b', '&amp;__c';\r\n}\r\n</code></pre></div><h2 id=\"disambiguation\">Disambiguation</h2><p>Expressions such as <code class=\"highlighter-rouge\">margin - n</code> could be interpreted both as a subtraction operation, as well as a property with an unary minus. To disambiguate, wrap the expression with parens:</p><div><pre><code>pad(n)\r\n  margin (- n)\r\n\r\nbody\r\n  pad(5px)\r\n</code></pre></div><p>Compiles to:</p><div><pre><code>body {\r\n  margin: -5px;\r\n}\r\n</code></pre></div><p>However, this is only true in functions (since functions act both as mixins, or calls with return values).</p><p>For example, the following is fine (and yields the same results as above):</p><div><pre><code>body\r\n  margin -5px\r\n</code></pre></div><p>Have weird property values that Stylus can’t process? <code class=\"highlighter-rouge\">unquote()</code> can help you out:</p><div><pre><code>filter unquote('progid:DXImageTransform.Microsoft.BasicImage(rotation=1)')\r\n</code></pre></div><p>Yields:</p><div><pre><code>filter progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\r\n</code></pre></div></div>\r\n"}